#!/usr/bin/env groovy
@Library('jenkins-bops@AFREXP-50020')
import bops.util.AppImage
import hudson.plugins.git.GitChangeSet
import hudson.tasks.test.AbstractTestResultAction

jenkinsTools = new bops.util.Jenkins()
branchTools = new bops.util.BranchCheck()
gchatTools = new bops.util.Gchat()

branchToBuild = env.BRANCH_NAME
configsToBuild = "origin/master"

println "BRANCH_NAME: '$env.BRANCH_NAME', CHANGE_TARGET: '${env.CHANGE_TARGET}'"

masterBranch = "origin/master"
baseBranch = env.CHANGE_TARGET
if (!baseBranch) {
    baseBranch = "master"
}

account = 'AIGEXP'
vertical = 'jservices'
repoKey = 'github-AIGEXP'
repo = 'JS-skylens'

version = branchTools.getVersion(branchToBuild)
qualifier = "SNAPSHOT"
projectVersion = "${version}-${qualifier}"

println "Branch To Build: $branchToBuild - version for branch: ${version}"

appImage = new AppImage(
        script: this,
        appName: 'skylens',
        version: version,
        repo: repo,
        repoBranch: branchToBuild,
        repoKey: repoKey,
        account: account,
        vertical: vertical,
        dockerfile: 'infrastructure/skylens/Dockerfile')

masterBranchAppImage = new AppImage(
        script: this,
        appName: 'skylens',
        repo: repo,
        repoBranch: masterBranch,
        repoKey: repoKey,
        account: account,
        vertical: vertical)

postgresqlMigrations = new AppImage(
        script: this,
        appName: 'skylens-postgresql-migrations',
        version: version,
        repo: repo,
        repoBranch: branchToBuild,
        repoKey: repoKey,
        account: account,
        vertical: vertical,
        dockerfile: 'infrastructure/skylens/Dockerfile')

ecrVariables = appImage.script.global.ecrVariables
ecrURL = ecrVariables[vertical]["ecrURL"]
ecrPath = ecrVariables[vertical]["ecrPath"]

pipeline {
    agent {
        kubernetes {
            defaultContainer 'builder'
            inheritFrom 'builder-java25'
        }
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
        skipDefaultCheckout()
    }

    environment {
        REPO_NAME = appImage.getRepo()
        CHANNEL_CI = '#js_skysystems_ci'
        NEXUS_URL = 'http://nexus-dev-services.jumia.com:8080'
        NEXUS_CREDENTIALS = credentials('nexus_dev_js')
        ECR_URL = "${ecrURL}"
        ECR_PATH = "${ecrPath}"
    }

    stages {
        stage('Checkout Repository') {
            steps {
                script {
                    withFolderProperties {

                        // get vars from folder and set at Environment level to use in all the stages
                        env.JIRA_TOKEN_ID = "${env.team}_jira_token"
                        env.TEAM = env.team
                        env.JIRA_PROJECT = env.JIRA_PROJECT
                    }

                    jenkinsTools.getECRLogin(vertical)
                    appImage.checkoutToSubdir(env.REPO_NAME)
                    initializeGradleProperties(env.REPO_NAME)
                    dir(env.REPO_NAME) {
                        currentBuild.description = "${projectVersion}.${appImage.getShortCommitId()} from ${appImage.getRepoBranch()}"

                        def migrationsDirectory = "driven-adapters/infrastructure/persistence/migrations-jpa"
                        env.RUN_DATABASE_REGRESSION_TESTS = hasChanges(masterBranch, migrationsDirectory)
                    }
                }
            }
        }

        stage('Commits & Jira Validation') {
            when {
                expression { env.BRANCH_NAME != "master" && env.BRANCH_NAME != masterBranch }
            }
            environment {
                JIRA_CREDENTIALS = credentials("${env.JIRA_TOKEN_ID}")
            }
            steps {
                dir(REPO_NAME) {
                    script {
                        def project = env.JIRA_PROJECT
                        Set inStatus = ["Backlog", "Released"]
                        jenkinsTools.checkTicketStatusForCommitMessages("Bearer ${env.JIRA_CREDENTIALS}",
                                baseBranch,
                                project,
                                inStatus)
                    }
                }
            }
        }

        stage('Build app') {
            steps {
                dir(REPO_NAME) {

                    script {
                        appImage.version = "${projectVersion}.${appImage.getShortCommitId()}"
                        appImage.build([] as String[], "build", '')
                        dockerBuilderRun("./gradlew --no-daemon --warn --stacktrace --parallel assemble")
                    }
                }
            }
        }

        stage('Run Tests') {
            failFast true
            parallel {
                stage('Tests') {
                    steps {
                        dir(REPO_NAME) {
                            script {
                                try {
                                    dockerBuilderRun("./gradlew --no-daemon " +
                                            "--console=plain --continue --info --stacktrace " +
                                            "test -x check -x jacocoTestCoverageVerification")
                                } finally {
                                    replaceProjectPathInXmlAndHtmlFiles()
                                }
                            }
                        }
                    }
                    post {
                        always {
                            dir(REPO_NAME) {
                                script {

                                    junit '**/build/test-results/*/*.xml'

                                    def java = scanForIssues tool: java()
                                    publishIssues issues: [java]

                                    def javaDoc = scanForIssues tool: javaDoc()
                                    publishIssues issues: [javaDoc]
                                }
                            }
                        }
                    }
                }

                stage('Database regression tests') {
                    when {
                        expression { env.RUN_DATABASE_REGRESSION_TESTS && false }
                    }
                    steps {
                        script {
                            env.MASTER_BRANCH_DIR = "${env.REPO_NAME}_${baseBranch}"
                            masterBranchAppImage.checkoutToSubdir(env.MASTER_BRANCH_DIR)
                            initializeGradleProperties(env.MASTER_BRANCH_DIR)

                            // Run main branch IT DAO tests with new database migrations
                            String migrationsDir = "/driven-adapters/infrastructure/persistence/migrations-jpa/src/main/resources/db"
                            String newMigrations = "${env.REPO_NAME}/${migrationsDir}"
                            String masterBranchMigrations = "${env.MASTER_BRANCH_DIR}/${migrationsDir}"
                            sh "rm -rf \"${masterBranchMigrations}\"/*"
                            sh "cp --recursive \"${newMigrations}\"/* \"${masterBranchMigrations}\""

                            dir(env.MASTER_BRANCH_DIR) {
                                try {
                                    dockerBuilderRun("./gradlew --no-daemon " +
                                            "--console=plain --continue --info --stacktrace " +
                                            "-b driven-adapters/infrastructure/persistence/postgresql-jpa/build.gradle.kts " +
                                            "-x check " +
                                            "-x jacocoTestCoverageVerification")
                                } finally {
                                    replaceProjectPathInXmlAndHtmlFiles()
                                }
                            }
                        }
                    }
                    post {
                        failure {
                            dir(env.MASTER_BRANCH_DIR) {
                                script {
                                    junit '**/build/test-results/*/*.xml'
                                }
                            }
                        }
                        always {
                            sh "rm -rf \"${env.MASTER_BRANCH_DIR}\" || exit 0"
                        }
                    }
                }
            }
        }

        stage('Code inspection') {
            steps {
                dir(REPO_NAME) {
                    script {
                        try {
                            dockerBuilderRun("./gradlew --no-daemon --console=plain " +
                                    "--continue --info --stacktrace --parallel " +
                                    "check jacocoTestCoverageVerification jacocoTestReport -x test")
                        } finally {
                            replaceProjectPathInXmlAndHtmlFiles()
                        }
                    }
                }
            }
            post {
                always {
                    dir(REPO_NAME) {
                        script {

                            recordCoverage(
                                    tools: [[parser : 'JACOCO',
                                             pattern: '**/build/test-results/jacoco/main.xml'
                                            ]]
                            )

                            def checkstyle = scanForIssues tool:
                                    checkStyle(pattern: '**/build/reports/checkstyle/*.xml', reportEncoding: 'UTF-8')

                            publishIssues issues: [checkstyle]

                            def spotbugs = scanForIssues tool: spotBugs(pattern: '**/build/reports/spotbugs/*.xml')
                            publishIssues issues: [spotbugs]

                            def java = scanForIssues tool: java()
                            def javaDoc = scanForIssues tool: javaDoc()

                            publishIssues(
                                    id: 'static-analysis',
                                    name: 'Static analysis',
                                    issues: [java, javaDoc, checkstyle, spotbugs],
                                    skipPublishingChecks: true)
                        }
                    }
                }
            }
        }

        stage("Docker App image build") {
            steps {
                dir(REPO_NAME) {
                    script {
                        appImage.version = "${projectVersion}.${appImage.getShortCommitId()}"
                        appImage.build([] as String[], "production", '')
                        appImage.tagDockerImage("local")
                    }
                }
            }
        }

        stage("Docker Flyway images build") {
            steps {
                dir(REPO_NAME) {
                    script {
                        postgresqlMigrations.version = "${projectVersion}.${appImage.getShortCommitId()}"
                        postgresqlMigrations.build([] as String[], "postgresql-migrations", '')
                        postgresqlMigrations.tagDockerImage("local")
                    }
                }
            }
        }

        stage('Acceptance Tests') {
            steps {
                dir(REPO_NAME) {
                    script {
                        try {
                            startContainersForAcceptanceTests()

                            dockerBuilderRun("./gradlew acceptanceTest")
                        } finally {
                            replaceProjectPathInXmlAndHtmlFiles()
                        }
                    }
                }
            }
            post {
                always {
                    dir(REPO_NAME) {
                        script {
                            acceptanceTestsReport()
                        }
                    }
                }
            }
        }

        stage("Tag & Push docker app image") {
            steps {
                dir(REPO_NAME) {
                    script {
                        appImage.tagDockerImage(appImage.version)
                        appImage.pushDockerImage()
                    }
                }
            }
        }

        stage("Tag & Push docker postgresql-migrations  image") {
            steps {
                dir(REPO_NAME) {
                    script {
                        postgresqlMigrations.tagDockerImage(appImage.version)
                        postgresqlMigrations.pushDockerImage()
                    }
                }
            }
        }

        stage('Deploy to staging') {
            when {
                environment name: 'BRANCH_NAME', value: 'master'
            }
            steps {
                script {
                    try {
                        build(job: "HMT/deploy/staging/skylens",
                                parameters: [string(name: "appName", value: appImage.getAppName()),
                                             string(name: "version", value: "${ECR_PATH}/${appImage.getAppName()}:${appImage.getVersion()}"),
                                             string(name: "namespaces", value: "glb"),
                                             string(name: "deployBranch", value: configsToBuild),
                                             string(name: "configsBranchTags", value: configsToBuild),
                                             booleanParam(name: "runDbMigrations", value: true)],
                                wait: true,
                                propagate: true)
                    } catch (hudson.AbortException ignore) {
                        unstable "Not building the job 'HMT/deploy/staging/skylens' as it doesn't exist"
                    }
                }
            }
        }
    }
    post {
        always {
            dir(REPO_NAME) {
                script {
                    sh 'PROJECT_HOME=$(pwd) docker compose --project-name "dev" ' +
                            '-f "tools/docker/dev/compose.yaml" down --rmi all --remove-orphans --volumes || exit 0'
                    sh 'docker system prune --volumes --force || exit 0'
                    sh 'rm -f gradle.properties || exit 0'
                }
            }
        }
        success {
            script {
                gchatTools.sendSimpleNotify(
                        gchatCredentialsId: CHANNEL_CI.replace("#", ""),
                        buildStatus: "success",
                        buildDetails: "Branch To Build: ${branchToBuild} - version for branch: ${version}"
                )
            }
        }
        failure {
            script {
                gchatTools.sendSimpleNotify(
                        gchatCredentialsId: CHANNEL_CI.replace("#", ""),
                        buildStatus: "failure",
                        buildDetails: "Branch To Build: ${branchToBuild} - version for branch: ${version}"
                )
            }

            dir(REPO_NAME) {
                script {
                    sh """
                            PROJECT_HOME=\$(pwd) JAVA_OPTS="" APP_OPTS="--spring.profiles.active=docker,qa-tests" \
                            docker compose --project-name dev -f "tools/docker/dev/compose.yaml" logs -n 10000 > 
                            after-acceptance-test-docker-logs.log
                        """.stripIndent()

                    archive 'after-acceptance-test-docker-logs.log'
                }
            }
        }
        unstable {
            script {
                gchatTools.sendSimpleNotify(
                        gchatCredentialsId: CHANNEL_CI.replace("#", ""),
                        buildStatus: "unstable",
                        buildDetails: "Branch To Build: ${branchToBuild} - version for branch: ${version}"
                )
            }
        }
    }
}

void replaceProjectPathInXmlAndHtmlFiles() {
    sh """
        replacer="s/\\/opt\\/app\\/src/\$(echo \$(pwd)| sed 's/\\//\\\\\\//g')/g"
        echo "Replace expression: \${replacer}"
        find ./ -path \"*/build/*.xml\" -exec sed -i -e \"\$replacer\" {} \\;
        find ./ -path \"*/build/*.html\" -exec sed -i -e \"\$replacer\" {} \\;
    """.stripIndent()
}

boolean hasChanges(String baseBranch, String directory) {
    def result = sh(
            script: "git diff --quiet HEAD ${baseBranch} -- ${directory} && echo false || echo true",
            returnStdout: true
    ).trim()

    return result == "true"
}

void initializeGradleProperties(String directory) {
    dir(directory) {
        script {
            sh '''
                echo \
                "NEXUS_URL=${NEXUS_URL}
                NEXUS_DOWNLOAD_PATH=/repository/maven-public
                NEXUS_UPLOAD_RELEASE_PATH=/repository/releases
                NEXUS_UPLOAD_SNAPSHOT_PATH=/repository/snapshots
                NEXUS_USERNAME=${NEXUS_CREDENTIALS_USR}
                NEXUS_PASSWORD=${NEXUS_CREDENTIALS_PSW}
                DOCKER_REGISTRY=${ECR_URL}/${ECR_PATH}
                PROJECT_HOME=${directory}" \
                > gradle.properties
            '''.stripIndent()
        }
    }
}

void dockerBuilderRun(String command) {
    sh """
        docker run \
          --rm \
          -i \
          -v "\$(pwd)":/opt/app/src/ \
          -v "${HOME}/.gradle":/opt/app/src/.gradle \
          -v "/var/run/docker.sock:/var/run/docker.sock" \
          --env NEXUS_URL=${NEXUS_URL} \
          --env NEXUS_USERNAME=${NEXUS_CREDENTIALS_USR} \
          --env NEXUS_PASSWORD=${NEXUS_CREDENTIALS_PSW} \
          --user="\$UID:\$GID" \
          --network host \
          ${appImage.appName} \
          ${command}
    """.stripIndent()
}

/**
 * Retrieves the test summary from the current build. If none, returns an empty string.
 */
def getTestSummary() {
    def testResults = currentBuild.rawBuild.getAction(AbstractTestResultAction.class)

    if (testResults == null) {
        return ""
    }

    def total = testResults.getTotalCount()
    def failed = testResults.getFailCount()
    def skipped = testResults.getSkipCount()
    def passed = total - failed - skipped

    return "Passed: ${passed}, Failed: ${failed}, Skipped: ${skipped}" as String
}

/**
 * Retrieves the change summary from the current build. If none, returns an empty string.
 */
def getChangeSummary() {

    return currentBuild.changeSets
            .collect { it.getItems() }
            .flatten()
            .collect { formatChange(it as GitChangeSet) }
            .join(System.lineSeparator())
}

/**
 * Formats change set entry: monospaced commit message followed by italicized author name.
 */
static def formatChange(GitChangeSet changeSetEntry) {

    return "`${changeSetEntry.getMsg()}` _${changeSetEntry.getAuthorName()}_" as String
}

/**
 * Start application containers using the previous built images
 * In case of failure starting containers then just return the last 50 lines of logs from all of them
 */
void startContainersForAcceptanceTests() {

    sh """
        PROJECT_HOME=\$(pwd) \
        JAVA_OPTS="" \
        APP_OPTS="--spring.profiles.active=docker,qa-tests" \
        ACL_INSTANCES="http://skylens-mock-application-dev:1080/" \
        docker compose --project-name dev -f "tools/docker/dev/compose.yaml" up -d || \
        docker compose --project-name dev -f "tools/docker/dev/compose.yaml" logs -n 10000 > acceptance-test-docker-logs.log
    """.stripIndent()

    archive 'acceptance-test-docker-logs.log'
}

/**
 * Collect and publish acceptance tests' reports
 */
void acceptanceTestsReport() {

    junit 'app/acceptance/build/test-results/acceptanceTest/*.xml'
    cucumber 'app/acceptance/build/reports/acceptanceTest/cucumber.json'
    publishHTML(
            target: [
                    allowMissing         : true,
                    alwaysLinkToLastBuild: false,
                    keepAll              : false,
                    reportDir            : "app/acceptance/build/reports/acceptanceTest/jacoco",
                    reportFiles          : 'index.html',
                    reportName           : 'QA Coverage Report'
            ]
    )
    publishHTML(
            target: [
                    allowMissing         : true,
                    alwaysLinkToLastBuild: false,
                    keepAll              : false,
                    reportDir            : "app/acceptance/build/reports/acceptanceTest/tests",
                    reportFiles          : 'index.html',
                    reportName           : 'Acceptance Tests Report'
            ]
    )
}
